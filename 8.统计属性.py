import time
import torch

print('程序开始时间：',time.strftime('%Y-%m-%d %H:%M:%S')) #记录程序开始时间

print('---------------------------------------------------------------------------------------------------------------')

a = torch.full([8],1).cuda()  # 生成一维，长度为8的张量a，并且使用1填充
print('张量a：',a)  # 输出a
print('张量a的类型：',a.type())  # 输出a的类型
a = a.float()  # 转换a的类型到浮点型
print('转换类型的张量a：',a)  # 输出a
print('张量a现在的类型：',a.type())  # 输出a的类型
b = a.view(2,4)  # 将a变换为二维2*4的张量b
print('a的变换b：',b)  # 输出b
c = a.view(2,2,2)  # 将a变换为三维2*2*2的张量c
print('a的另一种变换c：',c)  # 输出c
# 注意，计算2-范数的输入张量必须为浮点型。
print('a的1-范数：',a.norm(1))  # 计算a的1-范数，1-范数是所有元素绝对值之和。
print('b的1-范数：',b.norm(1))  # 计算b的1-范数，1-范数是所有元素绝对值之和。
print('c的1-范数：',c.norm(1))  # 计算c的1-范数，1-范数是所有元素绝对值之和。
print('a的2-范数：',a.norm(2))  # 计算a的2-范数，2-范数是所有元素绝对值平方之和再开平方根，即通常意义下的距离。
print('b的2-范数：',b.norm(2))  # 计算b的2-范数，2-范数是所有元素绝对值平方之和再开平方根，即通常意义下的距离。
print('c的2-范数：',c.norm(2))  # 计算c的2-范数，2-范数是所有元素绝对值平方之和再开平方根，即通常意义下的距离。
print('')
print('b在1维上的1-范数：',b.norm(1,dim=1))  # 输出b在1维上的1-范数
print('c在0维上的1-范数：',c.norm(1,dim=0))  # 输出c在0维上的1-范数
print('c在0维上的2-范数：',c.norm(2,dim=0))  # c在0维上的2-范数

print('---------------------------------------------------------------------------------------------------------------')

a2 = torch.arange(8).cuda()  # 生成从0到7的一维等差数列张量a2
a2 = a2.float()  # 转换a2的类型到浮点型
print('等差数列张量a2：',a2)  # 输出a2
a2= a2.view(2,4)  # 将a2变形为二维2*4张量
print('变形之后的a2',a2)  # 输出变形后的a2
print('a2所有元素之和：',a2.sum())  # 输出a2所有元素之和
print('a2元素最小值：',a2.min())  # 输出a2所有元素中的最小值
print('a2元素最大值：',a2.max())  # 输出a2所有元素的最大值
print('a2元素最小值位置：',a2.argmin())  # 输出a2所有元素的最小值所在的索引位置
print('a2元素最大值位置：',a2.argmax())  # 输出a2所有元素的最大值所在的索引位置
print('a2所有元素之积：',a2.prod())  # 输出a2所有元素之积
print('a2所有元素的平均数：',a2.mean())  # 输出a2所有元素的均值
print('a2所有元素的平方差：',a2.var())  # 输出a2所有元素的方差
print('a2按照第一维拆分后每一部分元素最大值位置：',a2.argmax(dim=1))  # 输出按照第一维拆分后，每一部分元素最大值的索引位置

print('---------------------------------------------------------------------------------------------------------------')

a3 = torch.rand([4,10]).cuda()  # 构造二维4*10矩阵张量a3
print('构造张量a3：',a3)  # 输出a3
print('二维最大值及其位置：',a3.max(dim=1))  # 输出a3在第二个维度的最大值及其位置（秩深度）
print('二维最大值及其位置（保留维度结构）：',a3.max(dim=1,keepdim=True))  # 输出a3在第二个维度的最大值及其位置（秩深度），并保留维度结构。
print('二维最大值的位置（保留维度结构）：',a3.argmax(dim=1,keepdim=True))  # 输出a3在第二个维度的最大值的位置（秩深度），并保留维度结构。

print('---------------------------------------------------------------------------------------------------------------')

print('张量a3：',a3)  # 输出a3
print('第二维上最大的前三个值与其位置：',a3.topk(3,dim=1))  # 输出以第二个维度划分，每一部分的前三个最大的元素以及它们在张量中的位置。
print('第二维上最小的前三个值与其位置：',a3.topk(3,dim=1,largest=False))  # 输出以第二个维度划分，每一部分的前三个最大的元素以及它们在张量中的位置。
print('第二维上第4小的值与其位置：',a3.kthvalue(4,dim=1))  # 输出以第二个维度划分，每一部分的第四小的元素以及它们在张量中的位置。

print('---------------------------------------------------------------------------------------------------------------')

print('张量a3：',a3)  # 输出a3
b3 = torch.rand([4,10]).cuda()
print('构造张量b3：',b3)  # 输出b3
print('b3元素是否大于0：',b3>0)  # 把张量b3元素大于0的地方置为1，其余为0.
print('b3元素是否不为0：',b3!=0)  # 把张量b3元素不等于0的地方置为1，其余为0.
print('b3元素是否小于0：',b3<0)  # 把张量b3元素小于0的地方置为1，其余为0.
print('a3与b3元素是否相等：',torch.eq(a3,b3))  # 比较a3与b3元素是否相等，相等的位置返回1，不相等返回0.
print('a3与b3是否相等（直接返回结果）：',torch.equal(a3,b3))  # 比较a3与b3元素是否相等，全部相等返回True，不相等返回False

print('---------------------------------------------------------------------------------------------------------------')

print('程序结束时间：',time.strftime('%Y-%m-%d %H:%M:%S'))  # 记录程序结束时间
